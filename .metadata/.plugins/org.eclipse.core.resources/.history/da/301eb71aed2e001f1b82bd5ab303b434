

#include "driverlib.h"
#include "device.h"
#include "f28p65x_device.h"
#include "f28p65x_examples.h"
#include "string.h"
#include <math.h>

#define PIEMASK0                       64
#define IFRMASK                        1

typedef struct {
    Uint32  BeginTimerCnt;
    Uint32  LastCycleTimerCnt;
    Uint32  MaxLoadTimeTick;
    float32  CycleTime_us;
    float32  LoadTime_us;
    float32  MaxLoadTime_us;
} CYCLELOADTIME_STRUCT;

typedef struct
{
    float32 MotorAxisEncoder_rad;
    float32 AllCloseLoopEncoder_rad;
    float32 MotorAxisEncoderSpeed_radps;
    float32 AllCloseLoopEncoder_radps;
    float32 MotorCurrent_A;
    float32 TorqueSensor_Nm;    //在cpu2采样计算
    float32 TargetPos_rad;
    float32 TargetSpeed_radps;
    float32 TargetTorque_Nm;
    float32 PosCtrlKp;
    float32 PosCtrlKi;
    float32 PosCtrlKd;
    float32 Reserve1;
    float32 Reserve2;
    float32 Reserve3;
}IPC_dataFromCPU1_t;

typedef struct
{
    float32 TargetCurrent_A;
    float32 Reserve1;
    float32 Reserve2;
    float32 Reserve3;
    Uint32  LifeTick;
}IPC_dataToCPU1_t;

void BaseBoardInit(void);
void ADCB_init(void);
void ScheduleDriveInit(void);

#pragma DATA_SECTION(ipcCPU2ToCPU1Data, "MSGRAM_CPU2_TO_CPU1")
IPC_dataToCPU1_t    ipcCPU2ToCPU1Data;

#pragma DATA_SECTION(ipcCPU1ToCPU2Data, "MSGRAM_CPU1_TO_CPU2")
IPC_dataFromCPU1_t   ipcCPU1ToCPU2Data;

CYCLELOADTIME_STRUCT Task50usTime;
CYCLELOADTIME_STRUCT Task1msTime;

Uint16 Task1msTick=0;
Uint16 Task10msTick=0;
Uint16 LastTask1msTick=0;
float32 GetDatBuff[20];
Uint32  LastCanFdInitSetFlag=0;
Uint32  LastCanFdStartSetFlag=0;
int32  TorqueSensorDiffAdSample=0;
int32  TorqueSensorSigleAdSample=0;
int32  TorqueSensorDiffAd=0;
int32  TorqueSensorSigleAd=0;
int32  TorqueSensorDiffAdSum=0;
int32 diff_torque_offset = 0;
int32 single_torque_offset = 0;
int32  TorqueSensorSigleAdSum=0;
Uint16 TorqueSensorSumTick=0;
float32 TorqueSensorSigleAd_pu = 0.0f;
float32 TorqueSensorDiffAd_pu = 0.0f;
bool is_first_torqute_init_ = true;

//#pragma CODE_SECTION(CycleLoadTimerCalcBegin, ".TI.ramfunc");
void inline CycleLoadTimerCalcBegin(CYCLELOADTIME_STRUCT * clt)
{
    clt->BeginTimerCnt = CpuTimer1.RegsAddr->TIM.all;

    clt->CycleTime_us = (float32)((Uint32)(clt->LastCycleTimerCnt - clt->BeginTimerCnt)) * 0.005F;

    clt->LastCycleTimerCnt = clt->BeginTimerCnt;
}

/**
 * @param t
 */
//#pragma CODE_SECTION(CycleLoadTimerCalcEnd, ".TI.ramfunc");
void inline CycleLoadTimerCalcEnd(CYCLELOADTIME_STRUCT * clt)
{
    clt->LoadTime_us = (float32)((Uint32)(clt->BeginTimerCnt - CpuTimer1.RegsAddr->TIM.all)) * 0.005F;

    if(clt->LoadTime_us > clt->MaxLoadTime_us){
        clt->MaxLoadTime_us = clt->LoadTime_us;
    }
    if(clt->MaxLoadTimeTick++ > 20000){
        clt->MaxLoadTime_us = 0;
        clt->MaxLoadTimeTick = 0;
    }
}


typedef struct {
    float32 alpha;  // 滤波器系数
    float32 prevOut; // 上一次的输出值
} IIRLowPassFilter;

IIRLowPassFilter filter;

void initFilter(IIRLowPassFilter *filter, float32 cutoffFreq, float32 sampleRate) {
    filter->alpha = exp(-2.0f * 3.1415f * cutoffFreq / sampleRate); // 计算alpha值
    filter->prevOut = 0.0f; // 初始化上一次的输出值
}

// 应用IIR低通滤波器
float32 applyFilter(IIRLowPassFilter *filter, float32 input) {
    float32 output = filter->alpha * input + (1.0f - filter->alpha) * filter->prevOut;
    filter->prevOut = output; // 更新上一次的输出值
    return output;
}

//
// Main
//
void main(void)
{
    BaseBoardInit();
    ADCB_init();
    initFilter(&filter, 1000.0f,10000.0f);
    ScheduleDriveInit();
    memset(&ipcCPU2ToCPU1Data, 0, sizeof(ipcCPU2ToCPU1Data));
    //
    // Take conversions indefinitely in loop
    //
    while(1){
        if((Task1msTick - LastTask1msTick) >= 10){
            LastTask1msTick = Task1msTick;

            //....10ms main task.......
            if(Task10msTick++ < 100){
                GPIO_writePin(72, 0);
            }else if(Task10msTick < 200){
                GPIO_writePin(72, 1);
            }else{
                Task10msTick = 0;
            }
        }
    }
}


//====================Task Fun============================//
//
// Task1ms
//
#pragma CODE_SECTION(TINT0_isr, ".TI.ramfunc");
interrupt void TINT0_isr(void)
{
    volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;

    PieCtrlRegs.PIEIER1.all &= ~PIEMASK0;      /* disable group1 lower/equal priority interrupts */

    asm(" RPT #5 || NOP");               /* wait 5 cycles */
    IFR &= ~IFRMASK;                           /* eventually disable lower/equal priority pending interrupts */
    PieCtrlRegs.PIEACK.all = IFRMASK;          /* ACK to allow other interrupts from the same group to fire */
    IER |= 1;
    EINT;                                /* global interrupt enable */

    CycleLoadTimerCalcBegin(&Task1msTime);

    //user 1ms Task...
    {
        Task1msTick++;

    }

    CycleLoadTimerCalcEnd(&Task1msTime);

    DINT;                                /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */
    PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;/*restore PIEIER register that was modified */
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}








#define TORQ_LOOP_TIME_S (1.0f/20000)

static float32 TestFrHz= 0;

float32 TestFr_Disturbance(void) {
    static float32 theata=0.0F;
    float32 TestFrDisturbance =0 ;

    theata = theata + (TORQ_LOOP_TIME_S * 6.2831853F) * TestFrHz;
    while(theata > 6.2831853F){
        theata = theata - 6.2831853F;
    }
    TestFrDisturbance = sinf(theata) * 1.5f; //__sin(theata);
    return TestFrDisturbance;
}

#define Ts 0.0001f
float32 fh,x11,x11_pre = 0,x22,x22_pre = 0,h = 0.001f,r = 60000,xx11,xx22;

int sign(float32 x)
{
    if(x > 0)
    return 1;
    else if(x < 0)
    return -1;
    else
    return 0;
}

float32 fhan(float32 x1,float32 x2,float32 r,float32 h)
{
    float32 d,d0,y,a0,a,fhan_value;
    d = r*h;
    d0 = h*d;
    y = x1 + h*x2;
    a0 = sqrt(d*d+8*r*fabsf(y));

    if(y <= d0 && y >=-d0)
    {
        a = x2 + y/h;
    }
    else
    {
        a = x2 + 0.5f*(a0 - d)*sign(y);
    }

    if(a <= d && a >= -d)
        fhan_value = -r*a/d;
    else
    {
        fhan_value = -r*sign(a);
    }
    return fhan_value;

}

void DifferentiateDiscreteSignal(float32 TorqueSensorDiffAd_pu)
{
    //反馈位置微分
    fh = fhan(x11_pre - TorqueSensorDiffAd_pu,x22_pre,r,h);//
    x11 = x11_pre + Ts*x22_pre;
    x22 = x22_pre + Ts*fh;
    x11_pre = x11;
    x22_pre = x22;
    xx11 = x11;
    xx22 = x22;
}


float32 get_test_fre(void)
{
    return GetDatBuff[12];
};

typedef enum
{
    TEST =0,
    INTER =1,
} TORQUE_SOURCE;
TORQUE_SOURCE torque_source  = INTER;

static float32 Kp = 150.0f;
static float32 Kd = 0.01f;
static int erro_cnt = 0;
#pragma CODE_SECTION(CIPC1_INT_isr, ".TI.ramfunc");
interrupt void CIPC1_INT_isr(void)
{
  static int16 waitTick=0;
  bool is_target_current_control_by_cpu2 = 0;
  float32 last_TargetTorque_Nm =0;
  float32 now_TargetTorque_Nm = 0;
  ADC_forceMultipleSOC(ADCB_BASE, (ADC_FORCE_SOC0 | ADC_FORCE_SOC1 | ADC_FORCE_SOC2 | ADC_FORCE_SOC3));
  CycleLoadTimerCalcBegin(&Task50usTime);


  float32 torque_base = 10000.f;
  float32 user_torque_setpoint  =0.0f;
  float32 erro = 0;
  float32 derivative  = 0;
  float32 TorqueSensorDiffAd_origin = 0;

  { //数据传输必须在50us任务开始传输
      //获取CPU1数据
      GetDatBuff[0] = ipcCPU1ToCPU2Data.MotorAxisEncoder_rad;
      GetDatBuff[1] = ipcCPU1ToCPU2Data.AllCloseLoopEncoder_rad;
      GetDatBuff[2] = ipcCPU1ToCPU2Data.MotorAxisEncoderSpeed_radps;
      GetDatBuff[3] = ipcCPU1ToCPU2Data.AllCloseLoopEncoder_radps;
      GetDatBuff[4] = ipcCPU1ToCPU2Data.MotorCurrent_A;
      GetDatBuff[5] = ipcCPU1ToCPU2Data.TorqueSensor_Nm; //
      GetDatBuff[6] = ipcCPU1ToCPU2Data.TargetPos_rad;
      GetDatBuff[7] = ipcCPU1ToCPU2Data.TargetSpeed_radps;
      GetDatBuff[8] = ipcCPU1ToCPU2Data.TargetTorque_Nm; // 速度环PI输出
      GetDatBuff[9] = ipcCPU1ToCPU2Data.PosCtrlKp;
      GetDatBuff[10] = ipcCPU1ToCPU2Data.PosCtrlKi;
      GetDatBuff[11] = ipcCPU1ToCPU2Data.PosCtrlKd;
      GetDatBuff[12] = ipcCPU1ToCPU2Data.Reserve1; // 3001-17
      GetDatBuff[13] = ipcCPU1ToCPU2Data.Reserve2; //保留
      GetDatBuff[14] = ipcCPU1ToCPU2Data.Reserve3; //保留
      GetDatBuff[15] = TorqueSensorDiffAdSample * 3.3F * 0.00001526F;
      GetDatBuff[16] = TorqueSensorSigleAdSample * 3.3F * 0.00001526F;
      GetDatBuff[17] = Task50usTime.CycleTime_us;
      GetDatBuff[18] = Task50usTime.LoadTime_us;

      is_target_current_control_by_cpu2 = (GetDatBuff[12] > 1)?  1 : 0;
      last_TargetTorque_Nm  = ipcCPU1ToCPU2Data.TargetTorque_Nm;


      { //力矩采样处理


              TorqueSensorDiffAd_origin = TorqueSensorDiffAdSample; //获取差分力矩AD
              TorqueSensorSigleAd = TorqueSensorSigleAdSample; //获取单端力矩AD
              TorqueSensorSumTick = 0;
              TorqueSensorDiffAdSum = 0;
              TorqueSensorSigleAdSum = 0;

              TorqueSensorDiffAd =  applyFilter(&filter,TorqueSensorDiffAd_origin);

              if( is_first_torqute_init_ )
              {
                  is_first_torqute_init_ = false;
                  diff_torque_offset = TorqueSensorDiffAd_origin;
                  single_torque_offset = TorqueSensorSigleAd;
              }
              TorqueSensorDiffAd -= diff_torque_offset;
              TorqueSensorSigleAd -= single_torque_offset;

              TorqueSensorDiffAd_pu = TorqueSensorDiffAd/torque_base;

              if(TorqueSensorDiffAd_pu > 0.5f  || TorqueSensorDiffAd_pu < -0.5f)
              {
                  erro_cnt++;
                  if(erro_cnt > 5 )
                      while(1);
              }

              //提取微分信号
              DifferentiateDiscreteSignal(TorqueSensorDiffAd_pu);


      }


      switch(torque_source)
      {
          case TEST:
              TestFrHz = get_test_fre();
               now_TargetTorque_Nm = TestFr_Disturbance();
          break;

          case INTER:
               erro = user_torque_setpoint - TorqueSensorDiffAd_pu;
               derivative  = -xx22;
              now_TargetTorque_Nm = Kp * erro + Kd *derivative;
          break;

          default:
          break;
      }

      if( is_target_current_control_by_cpu2 )
      {
          if(last_TargetTorque_Nm != now_TargetTorque_Nm)
          {
              ipcCPU2ToCPU1Data.TargetCurrent_A = now_TargetTorque_Nm;  //电流环给定值 A   0.5->0x3000 -7  6.0->0x3000-4
          }
          else
          {
              //set erro: 不能是相同值
          }
          ipcCPU2ToCPU1Data.LifeTick++;
      }

      ipcCPU2ToCPU1Data.Reserve1 = TorqueSensorDiffAd_origin/torque_base;// ipcCPU1ToCPU2Data.TargetTorque_Nm*1000/7; //监控4
      ipcCPU2ToCPU1Data.Reserve2 = TorqueSensorDiffAdSample/torque_base;//xx22;//Task50usTime.CycleTime_us;//监控5
      ipcCPU2ToCPU1Data.Reserve3 = Task50usTime.LoadTime_us; //保留




  }



  //Current loop sycn Task here...50us
  {
      //力矩算法单拍30us内完成，可分拍计算。。。

  }


  waitTick = 80;
  while(ADC_getInterruptStatus(ADCB_BASE, ADC_INT_NUMBER1) == false){ //AdcbRegs.ADCINTFLG.bit.ADCINT1 == false
      if(waitTick-- < 0){
          break;
      }
  }
  ADC_clearInterruptStatus(ADCB_BASE, ADC_INT_NUMBER1);

  TorqueSensorDiffAdSample = ((Uint32)((Uint32)AdcbResultRegs.ADCRESULT0 + (Uint32)AdcbResultRegs.ADCRESULT1))>>1;
  TorqueSensorSigleAdSample = ((Uint32)((Uint32)AdcbResultRegs.ADCRESULT2 + (Uint32)AdcbResultRegs.ADCRESULT3))>>1;

  CycleLoadTimerCalcEnd(&Task50usTime);

  IPC_ackFlagRtoL(IPC_CPU2_L_CPU1_R, IPC_FLAG1);
  PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}



//=================Init Fun============================//
//
// ScheduleDriveInit
//
void ScheduleDriveInit(void) {

    __disable_interrupts();

    /* Configure CPU-Timer 0 to interrupt every base rate. */
    /* Parameters:  Timer Pointer, CPU Freq in MHz, Period in usec. */
    ConfigCpuTimer(&CpuTimer0, 200, 0.001 * 1000000);
    StartCpuTimer0();

    ConfigCpuTimer(&CpuTimer1, 1, 0xFFFFFFFF);
    CpuTimer1.RegsAddr->PRD.all = 0xFFFFFFFF;
    StartCpuTimer1();

    //enable_interrupts
    EALLOW;
    PieVectTable.TIMER0_INT = &TINT0_isr;/* Hook interrupt to the ISR*/
    EDIS;
    PieCtrlRegs.PIEIER1.bit.INTx7 = 1;   /* Enable interrupt TIMER0_INT*/
    IER |= M_INT1;
    EALLOW;
    PieVectTable.CIPC1_INT = &CIPC1_INT_isr;/* Hook interrupt to the ISR*/
    EDIS;
    PieCtrlRegs.PIEIER1.bit.INTx14 = 1;  /* Enable interrupt CIPC1_INT*/
    IER |= M_INT1;

    IPC_sync(IPC_CPU2_L_CPU1_R, IPC_FLAG30);

    /* Enable global Interrupts and higher priority real-time debug events:*/
    EINT;                                /* Enable Global interrupt INTM*/
    ERTM;                               /* Enable Global realtime interrupt DBGM*/

    __enable_interrupts(); /* Enable Global Interrupt INTM and realtime interrupt DBGM */
}


//
// BaseBoardInit
//
void BaseBoardInit(void)
{
    DisableDog();

    memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (size_t)&RamfuncsLoadSize);

    Flash_initModule(FLASH0CTRL_BASE, FLASH0ECC_BASE, DEVICE_FLASH_WAITSTATES);

    EALLOW;
    CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;
    CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1;
    CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1;
    EDIS;

    DINT;
    IER = 0x0000;
    IFR = 0x0000;
    InitPieCtrl();
    InitPieVectTable();
    InitCpuTimers();

    EALLOW;
    CpuSysRegs.PCLKCR13.bit.ADC_B = 1;
    EDIS;

    IPC_waitForFlag(IPC_CPU2_L_CPU1_R, IPC_FLAG29);

    IPC_clearFlagLtoR(IPC_CPU2_L_CPU1_R, IPC_FLAG3);
}

//
// ADCB_init
//
void ADCB_init(){
    //
    // ADC Initialization: Write ADC configurations and power up the ADC
    //
    // Configures the analog-to-digital converter module prescaler.
    //
    ADC_setPrescaler(ADCB_BASE, ADC_CLK_DIV_8_0);
    //
    // Configures the analog-to-digital converter resolution and signal mode.
    //
    ADC_setMode(ADCB_BASE, ADC_RESOLUTION_16BIT, ADC_MODE_DIFFERENTIAL);
    //
    // Sets the timing of the end-of-conversion pulse
    //
    ADC_setInterruptPulseMode(ADCB_BASE, ADC_PULSE_END_OF_CONV);
    //
    // Powers up the analog-to-digital converter core.
    //
    ADC_enableConverter(ADCB_BASE);
    //
    // Delay for 1ms to allow ADC time to power up
    //
    DEVICE_DELAY_US(500);
    //
    // Enable alternate timings for DMA trigger
    //
    ADC_enableAltDMATiming(ADCB_BASE);
    //
    // SOC Configuration: Setup ADC EPWM channel and trigger settings
    //
    // Disables SOC burst mode.
    //
    ADC_disableBurstMode(ADCB_BASE);
    //
    // Sets the priority mode of the SOCs.
    //
    ADC_setSOCPriority(ADCB_BASE, ADC_PRI_ALL_ROUND_ROBIN);
    //
    // Start of Conversion 0 Configuration
    //
    //
    // Configures a start-of-conversion (SOC) in the ADC and its interrupt SOC trigger.
    //      SOC number      : 0
    //      Trigger         : ADC_TRIGGER_SW_ONLY
    //      Channel         : ADC_CH_ADCIN0_ADCIN1
    //      Sample Window   : 200 SYSCLK cycles
    //      Interrupt Trigger: ADC_INT_SOC_TRIGGER_NONE
    //
    ADC_setupSOC(ADCB_BASE, ADC_SOC_NUMBER0, ADC_TRIGGER_SW_ONLY, ADC_CH_ADCIN0_ADCIN1, 200U);
    ADC_setInterruptSOCTrigger(ADCB_BASE, ADC_SOC_NUMBER0, ADC_INT_SOC_TRIGGER_NONE);
    //
    // Start of Conversion 1 Configuration
    //
    //
    // Configures a start-of-conversion (SOC) in the ADC and its interrupt SOC trigger.
    //      SOC number      : 1
    //      Trigger         : ADC_TRIGGER_SW_ONLY
    //      Channel         : ADC_CH_ADCIN0_ADCIN1
    //      Sample Window   : 200 SYSCLK cycles
    //      Interrupt Trigger: ADC_INT_SOC_TRIGGER_NONE
    //
    ADC_setupSOC(ADCB_BASE, ADC_SOC_NUMBER1, ADC_TRIGGER_SW_ONLY, ADC_CH_ADCIN0_ADCIN1, 200U);
    ADC_setInterruptSOCTrigger(ADCB_BASE, ADC_SOC_NUMBER1, ADC_INT_SOC_TRIGGER_NONE);
    //
    // Start of Conversion 2 Configuration
    //
    //
    // Configures a start-of-conversion (SOC) in the ADC and its interrupt SOC trigger.
    //      SOC number      : 2
    //      Trigger         : ADC_TRIGGER_SW_ONLY
    //      Channel         : ADC_CH_ADCIN2
    //      Sample Window   : 200 SYSCLK cycles
    //      Interrupt Trigger: ADC_INT_SOC_TRIGGER_NONE
    //
    ADC_setupSOC(ADCB_BASE, ADC_SOC_NUMBER2, ADC_TRIGGER_SW_ONLY, ADC_CH_ADCIN2, 200U);
    ADC_setInterruptSOCTrigger(ADCB_BASE, ADC_SOC_NUMBER2, ADC_INT_SOC_TRIGGER_NONE);
    //
    // Start of Conversion 3 Configuration
    //
    //
    // Configures a start-of-conversion (SOC) in the ADC and its interrupt SOC trigger.
    //      SOC number      : 3
    //      Trigger         : ADC_TRIGGER_SW_ONLY
    //      Channel         : ADC_CH_ADCIN2
    //      Sample Window   : 200 SYSCLK cycles
    //      Interrupt Trigger: ADC_INT_SOC_TRIGGER_NONE
    //
    ADC_setupSOC(ADCB_BASE, ADC_SOC_NUMBER3, ADC_TRIGGER_SW_ONLY, ADC_CH_ADCIN2, 200U);
    ADC_setInterruptSOCTrigger(ADCB_BASE, ADC_SOC_NUMBER3, ADC_INT_SOC_TRIGGER_NONE);
    //
    // ADC Interrupt 1 Configuration
    //      Source  : ADC_INT_TRIGGER_EOC3
    //      Interrupt Source: enabled
    //      Continuous Mode : enabled
    //
    //
    ADC_setInterruptSource(ADCB_BASE, ADC_INT_NUMBER1, ADC_INT_TRIGGER_EOC3);
    ADC_clearInterruptStatus(ADCB_BASE, ADC_INT_NUMBER1);
    ADC_enableContinuousMode(ADCB_BASE, ADC_INT_NUMBER1);
    ADC_enableInterrupt(ADCB_BASE, ADC_INT_NUMBER1);
}


